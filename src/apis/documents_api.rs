/*
 * Onshape REST API
 *
 * The Onshape REST API consumed by all clients.
 *
 * The version of the OpenAPI document: 1.104
 * Contact: api-support@onshape.zendesk.com
 * Generated by: https://openapi-generator.tech
 */

use std::rc::Rc;
use std::borrow::Borrow;
#[allow(unused_imports)]
use std::option::Option;

use hyper;
use serde_json;
use futures::Future;

use super::{Error, configuration};
use super::request as __internal_request;

pub struct DocumentsApiClient<C: hyper::client::Connect> {
    configuration: Rc<configuration::Configuration<C>>,
}

impl<C: hyper::client::Connect> DocumentsApiClient<C> {
    pub fn new(configuration: Rc<configuration::Configuration<C>>) -> DocumentsApiClient<C> {
        DocumentsApiClient {
            configuration,
        }
    }
}

pub trait DocumentsApi {
    fn copy_workspace(&self, did: &str, wid: &str, bt_copy_document_params: Option<crate::models::BtCopyDocumentParams>) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn create_document(&self, bt_document_params: crate::models::BtDocumentParams) -> Box<dyn Future<Item = crate::models::BtDocumentInfo, Error = Error<serde_json::Value>>>;
    fn create_version(&self, did: &str, bt_version_or_workspace_params: crate::models::BtVersionOrWorkspaceParams) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn create_workspace(&self, did: &str, bt_version_or_workspace_params: Option<crate::models::BtVersionOrWorkspaceParams>) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn delete7(&self, did: &str, forever: Option<bool>) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn delete_workspace(&self, did: &str, wid: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn download_external_data(&self, did: &str, fid: &str, if_none_match: Option<&str>) -> Box<dyn Future<Item = std::path::PathBuf, Error = Error<serde_json::Value>>>;
    fn export2_json(&self, did: &str, wv: &str, wvid: &str, eid: &str, bt_export_model_params: Option<crate::models::BtExportModelParams>) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn get_acl(&self, did: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn get_current_microversion(&self, did: &str, wv: &str, wvid: &str) -> Box<dyn Future<Item = crate::models::BtMicroversionInfo, Error = Error<serde_json::Value>>>;
    fn get_document(&self, did: &str) -> Box<dyn Future<Item = crate::models::BtDocumentInfo, Error = Error<serde_json::Value>>>;
    fn get_document_permission_set(&self, did: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn get_documents(&self, q: Option<&str>, filter: Option<i32>, owner: Option<&str>, owner_type: Option<i32>, sort_column: Option<&str>, sort_order: Option<&str>, offset: Option<i32>, limit: Option<i32>, label: Option<&str>, project: Option<&str>, parent_id: Option<&str>) -> Box<dyn Future<Item = crate::models::BtGlobalTreeNodeListResponse, Error = Error<serde_json::Value>>>;
    fn get_elements1(&self, did: &str, wvm: &str, wvmid: &str, element_type: Option<&str>, element_id: Option<&str>, with_thumbnails: Option<bool>, link_document_id: Option<&str>) -> Box<dyn Future<Item = Vec<crate::models::BtDocumentElementInfo>, Error = Error<serde_json::Value>>>;
    fn get_insertables(&self, did: &str, wvm: &str, wvmid: &str, beta_capability_ids: Option<Vec<String>>, include_parts: Option<bool>, include_surfaces: Option<bool>, include_wires: Option<bool>, include_sketches: Option<bool>, include_reference_features: Option<bool>, include_assemblies: Option<bool>, include_features: Option<bool>, include_feature_studios: Option<bool>, include_part_studios: Option<bool>, include_blobs: Option<bool>, include_meshes: Option<bool>, include_flattened_bodies: Option<bool>, allowed_blob_mime_types: Option<&str>, max_feature_script_version: Option<i32>, include_applications: Option<bool>, allowed_application_mime_types: Option<&str>) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn get_version(&self, did: &str, vid: &str, parents: Option<bool>, link_document_id: Option<&str>) -> Box<dyn Future<Item = crate::models::BtVersionInfo, Error = Error<serde_json::Value>>>;
    fn get_versions1(&self, did: &str, offset: Option<i32>, limit: Option<i32>) -> Box<dyn Future<Item = Vec<crate::models::BtVersionInfo>, Error = Error<serde_json::Value>>>;
    fn get_workspaces1(&self, did: &str) -> Box<dyn Future<Item = Vec<crate::models::BtWorkspaceInfo>, Error = Error<serde_json::Value>>>;
    fn merge_into_workspace(&self, did: &str, wid: &str, bt_version_or_workspace_info: crate::models::BtVersionOrWorkspaceInfo) -> Box<dyn Future<Item = crate::models::BtDocumentMergeInfo, Error = Error<serde_json::Value>>>;
    fn restore_rendition(&self, did: &str, wid: &str, mvid: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn sync_application_elements(&self, did: &str, wid: &str, application_element_ids: Vec<String>, description: Option<&str>) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn update_external_references_to_latest_documents(&self, did: &str, wid: &str, eid: &str, bt_link_to_latest_document_params: Option<crate::models::BtLinkToLatestDocumentParams>) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
}

impl<C: hyper::client::Connect>DocumentsApi for DocumentsApiClient<C> {
    fn copy_workspace(&self, did: &str, wid: &str, bt_copy_document_params: Option<crate::models::BtCopyDocumentParams>) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/documents/{did}/workspaces/{wid}/copy".to_string())
            .with_auth(__internal_request::Auth::Oauth)
        ;
        req = req.with_path_param("did".to_string(), did.to_string());
        req = req.with_path_param("wid".to_string(), wid.to_string());
        req = req.with_body_param(bt_copy_document_params);
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn create_document(&self, bt_document_params: crate::models::BtDocumentParams) -> Box<dyn Future<Item = crate::models::BtDocumentInfo, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/documents".to_string())
            .with_auth(__internal_request::Auth::Oauth)
        ;
        req = req.with_body_param(bt_document_params);

        req.execute(self.configuration.borrow())
    }

    fn create_version(&self, did: &str, bt_version_or_workspace_params: crate::models::BtVersionOrWorkspaceParams) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/documents/d/{did}/versions".to_string())
            .with_auth(__internal_request::Auth::Oauth)
        ;
        req = req.with_path_param("did".to_string(), did.to_string());
        req = req.with_body_param(bt_version_or_workspace_params);
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn create_workspace(&self, did: &str, bt_version_or_workspace_params: Option<crate::models::BtVersionOrWorkspaceParams>) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/documents/d/{did}/workspaces".to_string())
            .with_auth(__internal_request::Auth::Oauth)
        ;
        req = req.with_path_param("did".to_string(), did.to_string());
        req = req.with_body_param(bt_version_or_workspace_params);
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn delete7(&self, did: &str, forever: Option<bool>) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/documents/{did}".to_string())
            .with_auth(__internal_request::Auth::Oauth)
        ;
        if let Some(ref s) = forever {
            req = req.with_query_param("forever".to_string(), s.to_string());
        }
        req = req.with_path_param("did".to_string(), did.to_string());
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn delete_workspace(&self, did: &str, wid: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/documents/d/{did}/workspaces/{wid}".to_string())
            .with_auth(__internal_request::Auth::Oauth)
        ;
        req = req.with_path_param("did".to_string(), did.to_string());
        req = req.with_path_param("wid".to_string(), wid.to_string());
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn download_external_data(&self, did: &str, fid: &str, if_none_match: Option<&str>) -> Box<dyn Future<Item = std::path::PathBuf, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/documents/d/{did}/externaldata/{fid}".to_string())
            .with_auth(__internal_request::Auth::Oauth)
        ;
        req = req.with_path_param("did".to_string(), did.to_string());
        req = req.with_path_param("fid".to_string(), fid.to_string());
        if let Some(param_value) = if_none_match {
            req = req.with_header_param("If-None-Match".to_string(), param_value.to_string());
        }

        req.execute(self.configuration.borrow())
    }

    fn export2_json(&self, did: &str, wv: &str, wvid: &str, eid: &str, bt_export_model_params: Option<crate::models::BtExportModelParams>) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/documents/d/{did}/{wv}/{wvid}/e/{eid}/export".to_string())
            .with_auth(__internal_request::Auth::Oauth)
        ;
        req = req.with_path_param("did".to_string(), did.to_string());
        req = req.with_path_param("wv".to_string(), wv.to_string());
        req = req.with_path_param("wvid".to_string(), wvid.to_string());
        req = req.with_path_param("eid".to_string(), eid.to_string());
        req = req.with_body_param(bt_export_model_params);
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn get_acl(&self, did: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/documents/{did}/acl".to_string())
            .with_auth(__internal_request::Auth::Oauth)
        ;
        req = req.with_path_param("did".to_string(), did.to_string());
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn get_current_microversion(&self, did: &str, wv: &str, wvid: &str) -> Box<dyn Future<Item = crate::models::BtMicroversionInfo, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/documents/d/{did}/{wv}/{wvid}/currentmicroversion".to_string())
            .with_auth(__internal_request::Auth::Oauth)
        ;
        req = req.with_path_param("did".to_string(), did.to_string());
        req = req.with_path_param("wv".to_string(), wv.to_string());
        req = req.with_path_param("wvid".to_string(), wvid.to_string());

        req.execute(self.configuration.borrow())
    }

    fn get_document(&self, did: &str) -> Box<dyn Future<Item = crate::models::BtDocumentInfo, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/documents/{did}".to_string())
            .with_auth(__internal_request::Auth::Oauth)
        ;
        req = req.with_path_param("did".to_string(), did.to_string());

        req.execute(self.configuration.borrow())
    }

    fn get_document_permission_set(&self, did: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/documents/{did}/permissionset".to_string())
            .with_auth(__internal_request::Auth::Oauth)
        ;
        req = req.with_path_param("did".to_string(), did.to_string());
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn get_documents(&self, q: Option<&str>, filter: Option<i32>, owner: Option<&str>, owner_type: Option<i32>, sort_column: Option<&str>, sort_order: Option<&str>, offset: Option<i32>, limit: Option<i32>, label: Option<&str>, project: Option<&str>, parent_id: Option<&str>) -> Box<dyn Future<Item = crate::models::BtGlobalTreeNodeListResponse, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/documents".to_string())
            .with_auth(__internal_request::Auth::Oauth)
        ;
        if let Some(ref s) = q {
            req = req.with_query_param("q".to_string(), s.to_string());
        }
        if let Some(ref s) = filter {
            req = req.with_query_param("filter".to_string(), s.to_string());
        }
        if let Some(ref s) = owner {
            req = req.with_query_param("owner".to_string(), s.to_string());
        }
        if let Some(ref s) = owner_type {
            req = req.with_query_param("ownerType".to_string(), s.to_string());
        }
        if let Some(ref s) = sort_column {
            req = req.with_query_param("sortColumn".to_string(), s.to_string());
        }
        if let Some(ref s) = sort_order {
            req = req.with_query_param("sortOrder".to_string(), s.to_string());
        }
        if let Some(ref s) = offset {
            req = req.with_query_param("offset".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = label {
            req = req.with_query_param("label".to_string(), s.to_string());
        }
        if let Some(ref s) = project {
            req = req.with_query_param("project".to_string(), s.to_string());
        }
        if let Some(ref s) = parent_id {
            req = req.with_query_param("parentId".to_string(), s.to_string());
        }

        req.execute(self.configuration.borrow())
    }

    fn get_elements1(&self, did: &str, wvm: &str, wvmid: &str, element_type: Option<&str>, element_id: Option<&str>, with_thumbnails: Option<bool>, link_document_id: Option<&str>) -> Box<dyn Future<Item = Vec<crate::models::BtDocumentElementInfo>, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/documents/d/{did}/{wvm}/{wvmid}/elements".to_string())
            .with_auth(__internal_request::Auth::Oauth)
        ;
        if let Some(ref s) = element_type {
            req = req.with_query_param("elementType".to_string(), s.to_string());
        }
        if let Some(ref s) = element_id {
            req = req.with_query_param("elementId".to_string(), s.to_string());
        }
        if let Some(ref s) = with_thumbnails {
            req = req.with_query_param("withThumbnails".to_string(), s.to_string());
        }
        if let Some(ref s) = link_document_id {
            req = req.with_query_param("linkDocumentId".to_string(), s.to_string());
        }
        req = req.with_path_param("did".to_string(), did.to_string());
        req = req.with_path_param("wvm".to_string(), wvm.to_string());
        req = req.with_path_param("wvmid".to_string(), wvmid.to_string());

        req.execute(self.configuration.borrow())
    }

    fn get_insertables(&self, did: &str, wvm: &str, wvmid: &str, beta_capability_ids: Option<Vec<String>>, include_parts: Option<bool>, include_surfaces: Option<bool>, include_wires: Option<bool>, include_sketches: Option<bool>, include_reference_features: Option<bool>, include_assemblies: Option<bool>, include_features: Option<bool>, include_feature_studios: Option<bool>, include_part_studios: Option<bool>, include_blobs: Option<bool>, include_meshes: Option<bool>, include_flattened_bodies: Option<bool>, allowed_blob_mime_types: Option<&str>, max_feature_script_version: Option<i32>, include_applications: Option<bool>, allowed_application_mime_types: Option<&str>) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/documents/d/{did}/{wvm}/{wvmid}/insertables".to_string())
            .with_auth(__internal_request::Auth::Oauth)
        ;
        if let Some(ref s) = beta_capability_ids {
            req = req.with_query_param("betaCapabilityIds".to_string(), s.join(",").to_string());
        }
        if let Some(ref s) = include_parts {
            req = req.with_query_param("includeParts".to_string(), s.to_string());
        }
        if let Some(ref s) = include_surfaces {
            req = req.with_query_param("includeSurfaces".to_string(), s.to_string());
        }
        if let Some(ref s) = include_wires {
            req = req.with_query_param("includeWires".to_string(), s.to_string());
        }
        if let Some(ref s) = include_sketches {
            req = req.with_query_param("includeSketches".to_string(), s.to_string());
        }
        if let Some(ref s) = include_reference_features {
            req = req.with_query_param("includeReferenceFeatures".to_string(), s.to_string());
        }
        if let Some(ref s) = include_assemblies {
            req = req.with_query_param("includeAssemblies".to_string(), s.to_string());
        }
        if let Some(ref s) = include_features {
            req = req.with_query_param("includeFeatures".to_string(), s.to_string());
        }
        if let Some(ref s) = include_feature_studios {
            req = req.with_query_param("includeFeatureStudios".to_string(), s.to_string());
        }
        if let Some(ref s) = include_part_studios {
            req = req.with_query_param("includePartStudios".to_string(), s.to_string());
        }
        if let Some(ref s) = include_blobs {
            req = req.with_query_param("includeBlobs".to_string(), s.to_string());
        }
        if let Some(ref s) = include_meshes {
            req = req.with_query_param("includeMeshes".to_string(), s.to_string());
        }
        if let Some(ref s) = include_flattened_bodies {
            req = req.with_query_param("includeFlattenedBodies".to_string(), s.to_string());
        }
        if let Some(ref s) = allowed_blob_mime_types {
            req = req.with_query_param("allowedBlobMimeTypes".to_string(), s.to_string());
        }
        if let Some(ref s) = max_feature_script_version {
            req = req.with_query_param("maxFeatureScriptVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = include_applications {
            req = req.with_query_param("includeApplications".to_string(), s.to_string());
        }
        if let Some(ref s) = allowed_application_mime_types {
            req = req.with_query_param("allowedApplicationMimeTypes".to_string(), s.to_string());
        }
        req = req.with_path_param("did".to_string(), did.to_string());
        req = req.with_path_param("wvm".to_string(), wvm.to_string());
        req = req.with_path_param("wvmid".to_string(), wvmid.to_string());
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn get_version(&self, did: &str, vid: &str, parents: Option<bool>, link_document_id: Option<&str>) -> Box<dyn Future<Item = crate::models::BtVersionInfo, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/documents/d/{did}/versions/{vid}".to_string())
            .with_auth(__internal_request::Auth::Oauth)
        ;
        if let Some(ref s) = parents {
            req = req.with_query_param("parents".to_string(), s.to_string());
        }
        if let Some(ref s) = link_document_id {
            req = req.with_query_param("linkDocumentId".to_string(), s.to_string());
        }
        req = req.with_path_param("did".to_string(), did.to_string());
        req = req.with_path_param("vid".to_string(), vid.to_string());

        req.execute(self.configuration.borrow())
    }

    fn get_versions1(&self, did: &str, offset: Option<i32>, limit: Option<i32>) -> Box<dyn Future<Item = Vec<crate::models::BtVersionInfo>, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/documents/d/{did}/versions".to_string())
            .with_auth(__internal_request::Auth::Oauth)
        ;
        if let Some(ref s) = offset {
            req = req.with_query_param("offset".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        req = req.with_path_param("did".to_string(), did.to_string());

        req.execute(self.configuration.borrow())
    }

    fn get_workspaces1(&self, did: &str) -> Box<dyn Future<Item = Vec<crate::models::BtWorkspaceInfo>, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/documents/d/{did}/workspaces".to_string())
            .with_auth(__internal_request::Auth::Oauth)
        ;
        req = req.with_path_param("did".to_string(), did.to_string());

        req.execute(self.configuration.borrow())
    }

    fn merge_into_workspace(&self, did: &str, wid: &str, bt_version_or_workspace_info: crate::models::BtVersionOrWorkspaceInfo) -> Box<dyn Future<Item = crate::models::BtDocumentMergeInfo, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/documents/{did}/workspaces/{wid}/merge".to_string())
            .with_auth(__internal_request::Auth::Oauth)
        ;
        req = req.with_path_param("did".to_string(), did.to_string());
        req = req.with_path_param("wid".to_string(), wid.to_string());
        req = req.with_body_param(bt_version_or_workspace_info);

        req.execute(self.configuration.borrow())
    }

    fn restore_rendition(&self, did: &str, wid: &str, mvid: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/documents/{did}/workspaces/{wid}/restore/{mvid}".to_string())
            .with_auth(__internal_request::Auth::Oauth)
        ;
        req = req.with_path_param("did".to_string(), did.to_string());
        req = req.with_path_param("wid".to_string(), wid.to_string());
        req = req.with_path_param("mvid".to_string(), mvid.to_string());
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn sync_application_elements(&self, did: &str, wid: &str, application_element_ids: Vec<String>, description: Option<&str>) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/documents/d/{did}/w/{wid}/syncApplicationElements".to_string())
            .with_auth(__internal_request::Auth::Oauth)
        ;
        req = req.with_query_param("applicationElementIds".to_string(), application_element_ids.join(",").to_string());
        if let Some(ref s) = description {
            req = req.with_query_param("description".to_string(), s.to_string());
        }
        req = req.with_path_param("did".to_string(), did.to_string());
        req = req.with_path_param("wid".to_string(), wid.to_string());
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn update_external_references_to_latest_documents(&self, did: &str, wid: &str, eid: &str, bt_link_to_latest_document_params: Option<crate::models::BtLinkToLatestDocumentParams>) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/documents/d/{did}/w/{wid}/e/{eid}/latestdocumentreferences".to_string())
            .with_auth(__internal_request::Auth::Oauth)
        ;
        req = req.with_path_param("did".to_string(), did.to_string());
        req = req.with_path_param("wid".to_string(), wid.to_string());
        req = req.with_path_param("eid".to_string(), eid.to_string());
        req = req.with_body_param(bt_link_to_latest_document_params);
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

}
